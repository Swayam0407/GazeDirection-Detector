{
  "version": 3,
  "sources": ["../index.ts", "../lib/utils/colorUtils.ts", "../lib/utils/annotationUtils.ts", "../lib/utils/mathUtils.ts", "../lib/api.ts"],
  "sourcesContent": ["export * from './lib/utils/annotationUtils';\nexport * from './lib/utils/colorUtils';\nexport * from './lib/utils/mathUtils';\nexport * from './lib/types';\nexport * from './lib/api';\n", "/**\n * Color palette for predicted classes.\n */\nexport const palette = [\n  '#811776',\n  '#FFFF00',\n  '#00FFFF',\n  '#FF00FF',\n  '#0000FF',\n  '#FF8F20',\n  '#AD2E24',\n  '#470400',\n  '#CFF000',\n  '#A7D141',\n  '#41D1B3',\n  '#70E9FF',\n  '#00ACED',\n  '#BFD8BD',\n  '#FF70E9',\n  '#FF5C9A',\n  '#BE408F',\n  '#8670FF',\n  '#333275',\n];\n\n/**\n * RGB color object\n */\nexport type RGB = { r: number; g: number; b: number };\n\n/**\n * convert a hex color to RGB\n */\nexport function hexToRgb(hex: string | null | undefined): RGB {\n  const fallback = { r: 0, g: 0, b: 0 };\n  if (!hex) return fallback;\n  const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n  return result\n    ? {\n        r: parseInt(result[1], 16),\n        g: parseInt(result[2], 16),\n        b: parseInt(result[3], 16),\n      }\n    : fallback;\n}\n\n/**\n * Check if a color is dark color or not.\n * \n * For example:\n * \n * ```javascript\n * const textColor = isDark(someColor) ? 'white' : 'black';\n * ```\n */\nexport function isDark(rgb: string | null | undefined | RGB) {\n  if (typeof rgb === 'string' || rgb === null || rgb === undefined) {\n    rgb = hexToRgb(rgb);\n  }\n  const { r, g, b } = rgb;\n  const brightness = r * 0.299 + g * 0.587 + b * 0.114;\n  return brightness < 150;\n}", "import { Annotation, InferenceResult, ObjectDetectionPrediction, SegmentationPrediction } from '../types';\nimport { hexToRgb, palette } from './colorUtils';\n\n/**\n * Convert server format predictions into a list of {@link Annotation} for easy rendering\n */\nexport function predictionsToAnnotations(inferenceResult?: InferenceResult | null) {\n  if (!inferenceResult) {\n    return [];\n  }\n  const { backbonepredictions, predictions } = inferenceResult;\n  const predictionsMap = predictions.bitmaps ?? backbonepredictions?.bitmaps ?? backbonepredictions;\n  return Object.entries(predictionsMap || []).map(([id, prediction]) => ({\n    id,\n    color: palette[prediction.labelIndex - 1],\n    coordinates: (prediction as ObjectDetectionPrediction).coordinates,\n    bitmap: (prediction as SegmentationPrediction).bitmap,\n    name: prediction.labelName,\n  } as Annotation));\n}\n\nconst RLE_OPTIONS = { map: { Z: '0', N: '1' } };\nconst rleDecodeMap: Record<string, string> = RLE_OPTIONS.map;\n\n/**\n * Decode string like 1N2Z1N3Z into 1001000\n */\nexport const runLengthDecode = (text: string) => {\n  if (!text) return text;\n  /**\n   * Groups all encoded pieces together\n   * 1N2Z1N3Z1N5Z1N2Z1N3Z1N3Z1N =>\n   * [\"12Z\", \"1N\", \"3Z\", \"1N\", \"5Z\", \"1N\", \"2Z\", \"1N\", \"3Z\", \"1N\", \"3Z\", \"1N\"]\n   */\n  const matches = text.match(/(\\d+)(\\w|\\s)/g);\n  /**\n   * Repeat each piece's last char with number\n   * 3Z = 000 1N = 1\n   */\n  return matches!.reduce((acc, str) => {\n    const decodedKey = rleDecodeMap[str.slice(-1)];\n    const times = Number(str.slice(0, str.length - 1));\n    return `${acc}${decodedKey.repeat(times)}`;\n  }, '');\n};\n\n/**\n * Convert a run-length-encoded string to a blob\n */\nexport const convertCompressedBitMapToBlob = async (\n  compressedBitMap: string,\n  color: string,\n  width: number,\n  height: number,\n) => {\n  const bitMap = runLengthDecode(compressedBitMap) || '';\n  const { r, g, b } = hexToRgb(color);\n  const offscreen = new OffscreenCanvas(width, height);\n  const context = offscreen.getContext('2d', {\n    desynchronized: true,\n  });\n  const imageData = context?.createImageData(width, height) as ImageData;\n  for (let i = 0; i < bitMap.length; i += 1) {\n    if (bitMap[i] === '1') {\n      imageData.data[4 * i + 0] = r; // R value\n      imageData.data[4 * i + 1] = g; // G value\n      imageData.data[4 * i + 2] = b; // B value\n      imageData.data[4 * i + 3] = 255 * 0.6; // A value\n    }\n  }\n  context?.putImageData(imageData, 0, 0);\n  return offscreen.convertToBlob();\n};", "/**\n * Count object array by a field.\n * \n * E.g. \n * ```\n * countBy([{name: 'Alice', sex: 'female'}, {name: 'Bob', sex: 'male'}, {name: 'Choe', sex: 'female'}], 'sex')\n * // returns { female: 2, male: 1 }\n * ```\n */\nexport const countBy = (arr: any[], key: string): Record<string, number> => {\n  return arr.reduce((res, item) => {\n    if (key in item) {\n      const value = item[key];\n      if (!(value in res)) {\n        res[value] = 0;\n      }\n      res[value]++;\n    }\n    return res;\n  }, {} as Record<string, number>);\n};", "import { ApiInfo, InferenceResult, ServerSegmentationPredictions } from './types';\n\nexport class ApiError extends Error {\n  body: any;\n  status?: number;\n  statusText?: string;\n  constructor(message: string){\n    super(message);\n  }\n}\n\n/**\n * Call Landing AI inference endpoint to get predictions\n */\nexport const getInferenceResult = async (apiInfo: ApiInfo, image: Blob): Promise<InferenceResult> => {\n  const formData = new FormData();\n  formData.append('file', image);\n\n  const result = await fetch(\n    apiInfo.endpoint + `&device_type=${process.env.LIB_DEVICE_TYPE ?? 'jslib'}`,\n    {\n      method: 'POST',\n      headers: {\n        Accept: '*/*',\n        ...(apiInfo.key\n          ? {\n            apikey: apiInfo.key,\n            apisecret: apiInfo.secret,\n          }\n          : undefined\n        )\n      },\n      body: formData,\n    }\n  );\n  const body: any = await result.text();\n  let bodyJson: any;\n  try {\n    bodyJson = JSON.parse(body);\n\n    // convert segmentation prediction fields to camel case\n    const bitmaps = (bodyJson as InferenceResult).predictions?.bitmaps\n      ?? ((bodyJson as InferenceResult).backbonepredictions as ServerSegmentationPredictions)?.bitmaps;\n    if (bitmaps) {\n      for (const key in bitmaps) {\n        const {\n          score,\n          label_name: labelName,\n          label_index: labelIndex,\n          defect_id: defectId,\n          bitmap,\n        } = bitmaps[key] as any;\n\n        bitmaps[key] = { score, labelName, labelIndex, defectId, bitmap };\n      }\n    }\n\n  } catch (e) {\n    // ignore error\n  }\n\n  if (result.status !== 200) {\n    const error = new ApiError(bodyJson?.message ?? body);\n    error.status = result.status;\n    error.statusText = result.statusText;\n    error.body = bodyJson;\n    throw error;\n  }\n  return bodyJson as any;\n};"],
  "mappings": "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",
  "names": ["core_exports", "__export", "ApiError", "convertCompressedBitMapToBlob", "countBy", "getInferenceResult", "hexToRgb", "isDark", "palette", "predictionsToAnnotations", "runLengthDecode", "__toCommonJS", "palette", "hexToRgb", "hex", "fallback", "result", "isDark", "rgb", "r", "g", "b", "predictionsToAnnotations", "inferenceResult", "_a", "_b", "backbonepredictions", "predictions", "predictionsMap", "id", "prediction", "palette", "RLE_OPTIONS", "rleDecodeMap", "runLengthDecode", "text", "acc", "str", "decodedKey", "times", "convertCompressedBitMapToBlob", "compressedBitMap", "color", "width", "height", "bitMap", "r", "g", "b", "hexToRgb", "offscreen", "context", "imageData", "i", "countBy", "arr", "key", "res", "item", "value", "ApiError", "message", "getInferenceResult", "apiInfo", "image", "_a", "_b", "_c", "_d", "_e", "formData", "result", "body", "bodyJson", "bitmaps", "key", "score", "labelName", "labelIndex", "defectId", "bitmap", "e", "error"]
}
